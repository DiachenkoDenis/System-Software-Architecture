# Практичне заняття №2

## Завдання 1 – Дослідження межі time_t та сегментів виконуваного файлу
### Умова завдання: 
необхідно написати програму мовою ANSI C, яка визначає момент, коли тип time_t досягає свого максимального значення (тобто "закінчується").

### Потрібно:

дослідити різницю між 32-бітною та 64-бітною архітектурою;

дослідити сегменти виконуваного файлу (text, data, bss) за допомогою команд ls -l, size, nm.

### Теоретична частина

Тип time_t використовується для зберігання часу у секундах від 1 січня 1970 року (Unix Epoch).

Його розмір залежить від архітектури:

якщо time_t має 4 байти (32-bit), максимальне значення приблизно відповідає даті 19 січня 2038 року (проблема 2038);

якщо time_t має 8 байт (64-bit), межа знаходиться дуже далеко в майбутньому.

Максимальне значення залежить від розміру типу:

для 4 байтів — використовується INT_MAX;

для 8 байтів — використовується LLONG_MAX.

## Опис роботи програми

Програма:

Визначає розмір типу time_t за допомогою sizeof(time_t).

В залежності від розміру:

якщо 4 байти — бере INT_MAX;

якщо 8 байт — бере LLONG_MAX.

Виводить максимальне числове значення.

Перетворює його у дату за допомогою функції ctime().

Виводить отриману дату (якщо перетворення можливе).

Код програми
```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main(void) {

    printf("=== time_t research ===\n");
    printf("sizeof(time_t) = %zu bytes\n", sizeof(time_t));

    time_t t_end;

    if (sizeof(time_t) == 4) {
        t_end = (time_t)INT_MAX;
        printf("Assuming 32-bit time_t.\n");
    } else {
        t_end = (time_t)LLONG_MAX;
        printf("Assuming 64-bit time_t.\n");
    }

    printf("End value = %lld\n", (long long)t_end);

    char *result = ctime(&t_end);

    if (result != NULL) {
        printf("End date = %s", result);
    } else {
        printf("ctime() cannot convert this value on this system.\n");
    }

    return 0;
}
```

### Дослідження 32-bit та 64-bit

Для 64-бітної системи:
```
gcc time_limit.c -o time_limit
./time_limit
```

Для 32-бітної збірки (якщо підтримується система):
```
gcc -m32 time_limit.c -o time_limit32
./time_limit32
```
Очікувана різниця:
Архітектура	sizeof(time_t)	Межа
32-bit	4 байти	~2038 рік
64-bit	8 байт	Дуже далеке майбутнє
Дослідження сегментів виконуваного файлу

Після компіляції виконано аналіз сегментів.

Перевірка розміру файлу:

ls -l time_limit


Перевірка сегментів:

size time_limit


Вивід містить:

text — сегмент коду (інструкції)

data — ініціалізовані глобальні змінні

bss — неініціалізовані глобальні змінні

Додатковий аналіз:

nm time_limit
