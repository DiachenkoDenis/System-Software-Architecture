# Практичне заняття №2

## Завдання 1 – Дослідження межі time_t та сегментів виконуваного файлу
### Умова завдання

У цьому завданні потрібно написати програму мовою ANSI C, яка визначає момент, коли тип time_t досягає свого максимального значення. Також необхідно дослідити різницю між 32-бітною та 64-бітною архітектурою і перевірити сегменти виконуваного файлу (text, data, bss) за допомогою команд ls -l, size та nm.

### Теоретична частина

Тип time_t використовується для зберігання часу у вигляді кількості секунд від 1 січня 1970 року (Unix Epoch). Його розмір залежить від архітектури системи. Якщо time_t займає 4 байти (32-bit), його максимальне значення приблизно відповідає даті 19 січня 2038 року -це так звана проблема 2038 року. Якщо ж time_t має 8 байт (64-bit), межа значно більша і знаходиться дуже далеко в майбутньому.

Для визначення максимально можливого значення використовується INT_MAX у випадку 4 байтів і LLONG_MAX у випадку 8 байтів.

### Опис роботи програми

Програма спочатку визначає розмір типу time_t за допомогою sizeof(time_t). Залежно від отриманого значення вона обирає відповідну верхню межу: INT_MAX для 32-бітного випадку або LLONG_MAX для 64-бітного. Далі це значення виводиться як число секунд, після чого за допомогою функції ctime() перетворюється у читабельну дату.

Таким чином можна побачити, до якої дати може “дійти” time_t у конкретній системі та як це залежить від архітектури.
Необхідно написати програму мовою ANSI C, яка визначає момент, коли тип time_t досягає свого максимального значення.

Код програми
```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main(void) {

    printf("=== time_t research ===\n");
    printf("sizeof(time_t) = %zu bytes\n", sizeof(time_t));

    time_t t_end;

    if (sizeof(time_t) == 4) {
        t_end = (time_t)INT_MAX;
        printf("Assuming 32-bit time_t.\n");
    } else {
        t_end = (time_t)LLONG_MAX;
        printf("Assuming 64-bit time_t.\n");
    }

    printf("End value = %lld\n", (long long)t_end);

    char *result = ctime(&t_end);

    if (result != NULL) {
        printf("End date = %s", result);
    } else {
        printf("ctime() cannot convert this value on this system.\n");
    }

    return 0;
}
```

### Дослідження 32-bit та 64-bit

Для 64-бітної системи:
```
gcc time_limit.c -o time_limit
./time_limit
```
![64-bit](screenshots/pr2(11).png)

На скріншоті відображено запуску програми за допомогою 64-бітної системи.

Для 32-бітної збірки (якщо підтримується система):
```
gcc -m32 time_limit.c -o time_limit32
./time_limit32
```
![32-bit](screenshots/pr2(1,2).png)

На скріншоті відображено запуску програми за допомогою 32-бітної системи.

Очікувана різниця: архітектура	sizeof(time_t)
32-bit	4 байти	~2038 рік
64-bit	8 байт	Дуже далеке майбутнє

Дослідження сегментів виконуваного файлу



Після компіляції виконано аналіз сегментів.

Перевірка розміру файлу:
```
ls -l time_limit
```

Перевірка сегментів:
```
size time_limit
```
![size](screenshots/pr2(size).png)

На скріншоті відображено результат перевірки сегментів.
Вивід містить:

text — сегмент коду (інструкції)

data — ініціалізовані глобальні змінні

bss — неініціалізовані глобальні змінні

Додатковий аналіз:

nm time_limit

![size](screenshots/pr2(nm).png)

На скріншоті відображено результат додаткового аналізу.
